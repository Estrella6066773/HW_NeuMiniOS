# NeuMiniOS 操作系统课程作业指导文档

## 📋 作业概览

### 基本信息
- **课程单元**: 操作系统 (Operating Systems)
- **单元代码**: UFCENR-0-2
- **作业类型**: 作品集练习 (Portfolio of Exercises)
- **权重**: 占总成绩的 50%
- **预计工作量**: 20 小时
- **提交截止日期**: 2025年12月19日 23:59 (中国标准时间)
- **团队规模**: 3 人团队

### 评估任务
- **Task 1 - 实现**: 50%
- **Task 2 - 技术评审**: 50%

---

## 🎯 Task 1: NeuMiniOS 实现

### 系统架构概述

NeuMiniOS 是一个运行在 Linux 主机操作系统之上的小型操作系统，使用 C 语言实现。系统包含以下核心组件：

1. **命令行界面 (CLI)**
2. **进程管理子系统**
3. **文件管理子系统**
4. **NeuBoot 引导加载器**
5. **NeuMiniOS 命令集**

---

## 📝 详细实现要求

### 1. 命令行界面 (CLI) - 15%

#### 基本要求
- ✅ 提供类似 Linux Bash shell 的文本界面
- ✅ 使用 `>` 作为提示符
- ✅ 能够从 CLI 执行所有 NeuMiniOS 命令
- ✅ 命令输出显示在新行，输出后显示新提示符

#### 加分项
- ⭐ **命令历史功能**
  - 实现命令历史记录
  - 支持通过方向键（如 ↑ 键）浏览历史命令
  - 类似 Linux Bash 的历史导航功能

#### 实施建议
```c
// 建议的数据结构
typedef struct {
    char** history;      // 历史命令数组
    int history_count;    // 历史命令数量
    int history_index;    // 当前历史索引
    int max_history;      // 最大历史记录数
} CLI_History;

// 主循环示例
void cli_loop() {
    char* input;
    while (1) {
        printf("> ");
        input = read_input();  // 读取用户输入（支持历史导航）
        execute_command(input);
    }
}
```

---

### 2. 进程管理子系统 - 20%

#### 基本要求
- ✅ 管理最多 5 个运行中的进程
- ✅ 每个进程有唯一 ID
- ✅ 使用 `fork()` 创建子进程执行 NeuMiniOS 的 `run` 命令
- ✅ 使用数组结构管理进程信息

#### 加分项
- ⭐ **使用链表结构管理进程信息**
  - 替代数组，使用链表存储进程信息
  - 更灵活的内存管理

#### 实施建议
```c
// 数组方式（基本要求）
typedef struct {
    pid_t pid;           // Linux 进程 ID
    int process_id;      // NeuMiniOS 进程 ID
    char* command;       // 执行的命令
    int status;          // 进程状态
} Process;

Process processes[5];    // 最多 5 个进程
int process_count = 0;

// 链表方式（加分项）
typedef struct ProcessNode {
    pid_t pid;
    int process_id;
    char* command;
    int status;
    struct ProcessNode* next;
} ProcessNode;

ProcessNode* process_list = NULL;
```

#### 关键函数
- `create_process()`: 创建新进程
- `list_processes()`: 列出所有进程（`plist` 命令）
- `stop_process()`: 停止进程（`stop` 命令）

---

### 3. 文件管理子系统 - 20%

#### 基本要求
- ✅ 使用大型内存数据结构作为"磁盘镜像"
- ✅ 实现文件存储和检索功能
- ✅ 使用**链表**记录所有文件，包含指向文件内容的内存指针
- ✅ 动态分配内存存储每个文件的二进制内容
- ✅ 从磁盘镜像提取可执行文件到 Linux 主机系统以便执行
- ✅ 设置文件权限使其可执行

#### 加分项
- ⭐ **目录层次结构**
  - 实现目录系统
  - 添加 `cd` 和 `mkdir` 命令
  - 调整文件管理结构支持目录层次

#### 实施建议
```c
// 文件节点结构（基本）
typedef struct FileNode {
    char* filename;
    void* data;              // 文件内容的内存指针
    size_t size;             // 文件大小
    struct FileNode* next;   // 链表指针
} FileNode;

// 带目录支持的结构（加分项）
typedef struct FileNode {
    char* filename;
    char* path;              // 文件路径
    void* data;
    size_t size;
    int is_directory;        // 是否为目录
    struct FileNode* children;  // 子文件/目录
    struct FileNode* next;      // 同级文件
    struct FileNode* parent;    // 父目录
} FileNode;

FileNode* disk_image = NULL;  // 磁盘镜像根节点
char* current_directory = "/"; // 当前目录
```

#### 关键功能
- `add_file()`: 添加文件到磁盘镜像
- `get_file()`: 从磁盘镜像检索文件
- `extract_to_host()`: 提取文件到 Linux 主机系统
- `set_executable_permissions()`: 设置文件权限

---

### 4. NeuBoot 引导加载器 - 15%

#### 基本要求
- ✅ 创建 NeuMiniOS 内存磁盘镜像
- ✅ 从 Linux 主机系统的指定文件夹上传所有可执行文件和数据文件
- ✅ 动态分配内存存储每个文件
- ✅ 填充文件管理结构
- ✅ 启动 CLI

#### 加分项
- ⭐ **启动信息显示**
  - 显示导入的文件列表
  - 显示磁盘镜像大小
  - 显示启动序列信息

#### 实施建议
```c
void neuboot() {
    printf("=== NeuMiniOS Boot Loader ===\n");
    
    // 1. 初始化磁盘镜像
    disk_image = initialize_disk_image();
    
    // 2. 扫描指定文件夹
    char* source_dir = "./neuminios_files/";  // 可执行文件和数据文件目录
    scan_and_load_files(source_dir);
    
    // 3. 显示启动信息（加分项）
    display_boot_info();
    
    // 4. 启动 CLI
    printf("NeuMiniOS ready. Starting CLI...\n");
    cli_loop();
}
```

---

### 5. NeuMiniOS 命令集 - 30%

#### 必须实现的命令

| 命令 | 描述 | 示例 | 实现要点 |
|------|------|------|----------|
| `list` | 列出当前目录所有文件 | `> list` | 遍历文件链表，显示文件名 |
| `view <file>` | 输出文件内容到 CLI | `> view datafile` | 从磁盘镜像读取文件并显示 |
| `delete <file>` | 从磁盘镜像删除文件 | `> delete datafile` | 从链表中移除节点，释放内存 |
| `copy <file> <newfile>` | 复制文件 | `> copy datafile newfile` | 创建新文件节点，复制数据 |
| `rename <file> <newname>` | 重命名文件 | `> rename newfile filecopy` | 修改文件名 |
| `plist` | 列出所有运行进程 | `> plist` | 显示进程数组/链表 |
| `stop <pid>` | 停止运行中的进程 | `> stop 1` | 使用 `kill()` 终止进程 |
| `run <file>` | 运行可执行文件 | `> run helloworld` | 提取文件，fork 子进程执行 |

#### 加分命令
- `cd <directory>`: 切换目录（需要实现目录层次）
- `mkdir <directory>`: 创建目录（需要实现目录层次）

#### 命令解析建议
```c
typedef struct {
    char* command;      // 命令名
    char** args;        // 参数数组
    int arg_count;      // 参数数量
} ParsedCommand;

ParsedCommand* parse_command(char* input) {
    // 解析输入字符串，分离命令和参数
    // 返回 ParsedCommand 结构
}

void execute_command(char* input) {
    ParsedCommand* cmd = parse_command(input);
    
    if (strcmp(cmd->command, "list") == 0) {
        list_files();
    } else if (strcmp(cmd->command, "view") == 0) {
        view_file(cmd->args[0]);
    }
    // ... 其他命令
}
```

---

## 🧪 测试要求

### 必须提供的测试文件
1. **至少一个文本文件**：用于测试 `view` 命令
   - 例如：`datafile.txt` 包含一些文本内容

2. **至少一个可执行文件**：用于测试 `run` 命令
   - 推荐：实现 "Hello World" 程序
   - 编译为可执行文件，放在指定文件夹中

### Hello World 示例
```c
// helloworld.c
#include <stdio.h>

int main() {
    printf("Hello World\n");
    return 0;
}
```

编译：
```bash
gcc -o helloworld helloworld.c
```

---

## 📹 演示视频要求

### 必须录制的内容
- ✅ **时长**: 不超过 15 分钟
- ✅ **格式**: .mp4
- ✅ **参与**: 所有团队成员必须参与

### 演示内容清单
1. ✅ NeuBoot 引导加载器启动 NeuMiniOS
2. ✅ 所有 NeuMiniOS 命令的运行演示
   - 使用 `list` 显示文件列表
   - 使用 `view` 查看文件内容
   - 使用 `delete` 删除文件，然后用 `list` 验证
   - 使用 `copy` 和 `rename` 操作文件
   - 使用 `run` 执行可执行文件
   - 使用 `plist` 查看进程
   - 使用 `stop` 停止进程
3. ✅ 所有加分功能的演示
   - 命令历史（如果实现）
   - 目录层次（如果实现）
   - 启动信息显示（如果实现）

---

## 📊 贡献矩阵

### 要求
- 必须提交单独的 Word 或 PDF 文件
- 记录每个团队成员在各个子系统的贡献百分比
- 用于分配 Task 1 的分数

### 模板
| UWE ID | CLI | 进程管理 | 文件管理 | NeuBoot | NeuMiniOS 命令 |
|--------|-----|---------|---------|---------|----------------|
| Student 1 | 描述贡献<br>__% | 描述贡献<br>__% | 描述贡献<br>__% | 描述贡献<br>__% | 描述贡献<br>__% |
| Student 2 | 描述贡献<br>__% | 描述贡献<br>__% | 描述贡献<br>__% | 描述贡献<br>__% | 描述贡献<br>__% |
| Student 3 | 描述贡献<br>__% | 描述贡献<br>__% | 描述贡献<br>__% | 描述贡献<br>__% | 描述贡献<br>__% |

---

## 🎤 Task 2: 技术评审

### 评审要求
- **时长**: 10 分钟
- **形式**: 问答环节 + 系统演示
- **参与**: 所有团队成员必须参加
- **评分**: 
  - 个人表现: 65%
  - 团队表现: 35%

### 准备事项
1. ✅ **两台笔记本电脑**
   - 一台运行 NeuMiniOS 系统
   - 一台打开代码（IDE）

2. ✅ **所有成员准备**
   - 能够回答实现细节问题
   - 能够解释设计决策
   - 能够评估实现

3. ✅ **可能的问题类型**
   - 为什么选择这种数据结构？
   - 如何管理内存？
   - 进程如何创建和终止？
   - 文件系统如何组织？
   - 如果使用了 AI 辅助，如何使用的？

### 注意事项
- ⚠️ **缺席 = 0 分**
- ⚠️ 如有特殊情况，必须提前通知课程负责人

---

## 📦 提交要求

### 提交内容
将所有文件压缩为单个 zip 文件，包含：

1. ✅ **所有 .c 源文件**
2. ✅ **所有 .h 头文件**
3. ✅ **贡献矩阵报告**（Word 或 PDF）
4. ✅ **演示视频**（.mp4 格式）

### 文件结构建议
```
neuminios_submission.zip
├── src/
│   ├── cli.c
│   ├── cli.h
│   ├── process.c
│   ├── process.h
│   ├── file_system.c
│   ├── file_system.h
│   ├── neuboot.c
│   ├── neuboot.h
│   ├── commands.c
│   └── commands.h
├── neuminios_files/
│   ├── helloworld          # 可执行文件
│   └── datafile.txt        # 数据文件
├── contribution_matrix.pdf
└── demonstration.mp4
```

---

## 🚀 实施路线图

### 第 1 周：团队组建与规划
- [ ] 组建 3 人团队
- [ ] 分配任务和责任
- [ ] 设置开发环境（Linux 系统）
- [ ] 熟悉 C 语言编程

### 第 2 周：CLI 基础实现
- [ ] 实现基本的 CLI 循环
- [ ] 实现命令解析
- [ ] 实现基本提示符
- [ ] 测试基本命令输入输出

### 第 3 周：文件管理系统
- [ ] 设计文件节点数据结构
- [ ] 实现文件添加功能
- [ ] 实现文件检索功能
- [ ] 实现 `list`、`view`、`delete`、`copy`、`rename` 命令

### 第 4 周：进程管理
- [ ] 设计进程数据结构（数组或链表）
- [ ] 实现进程创建（fork）
- [ ] 实现 `plist` 和 `stop` 命令
- [ ] 实现文件提取和执行功能
- [ ] 实现 `run` 命令

### 第 5 周：NeuBoot 引导加载器
- [ ] 实现文件扫描功能
- [ ] 实现磁盘镜像初始化
- [ ] 实现文件上传到内存
- [ ] 集成 CLI 启动
- [ ] （可选）添加启动信息显示

### 第 6 周：优化与测试
- [ ] （可选）实现命令历史
- [ ] （可选）实现目录层次
- [ ] 全面测试所有功能
- [ ] 修复 bug
- [ ] 录制演示视频
- [ ] 准备技术评审

---

## 💡 关键技术要点

### 1. 内存管理
```c
// 动态分配内存存储文件
void* file_data = malloc(file_size);
memcpy(file_data, source_data, file_size);

// 记得释放内存
free(file_data);
```

### 2. 进程管理
```c
// 创建子进程
pid_t pid = fork();
if (pid == 0) {
    // 子进程：执行命令
    execv(extracted_file_path, args);
} else {
    // 父进程：记录进程信息
    add_process(pid, process_id, command);
}
```

### 3. 文件权限设置
```c
// 设置文件可执行权限
chmod(file_path, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
```

### 4. 目录扫描
```c
// 使用 dirent.h 扫描目录
DIR* dir = opendir(directory_path);
struct dirent* entry;
while ((entry = readdir(dir)) != NULL) {
    // 处理每个文件
}
closedir(dir);
```

---

## ✅ 通过标准（40%）

### 最低要求
- ✅ 实现至少 3 个 NeuMiniOS 命令
- ✅ 基本的文件系统（能够存储和检索文件）
- ✅ 基本的 NeuBoot 引导加载器
- ✅ 系统可以运行（即使有一些错误）
- ✅ 参加技术评审并展示基本技术理解

---

## 🌟 高分策略（85%+）

### 实现要求
- ✅ 所有命令正常工作，无错误
- ✅ 所有子系统完整实现
- ✅ 实现至少 2-3 个加分功能：
  - 命令历史
  - 目录层次（cd, mkdir）
  - 启动信息显示
  - 链表进程管理

### 技术评审准备
- ✅ 深入理解代码实现
- ✅ 能够解释设计决策
- ✅ 能够评估实现的优缺点
- ✅ 清晰、自信地回答问题

---

## ⚠️ 重要注意事项

### AI 使用政策
- ✅ **允许使用** AI 工具辅助：
  - 起草和结构化内容
  - 翻译内容
  - 提供想法和灵感
  - 帮助理解概念

- ⚠️ **必须做到**：
  - 理解所有 AI 生成的代码
  - 在技术评审中诚实说明 AI 使用情况
  - 确保整个团队理解代码

### 学术诚信
- ✅ 允许与团队成员协作
- ❌ **禁止**与其他团队共享代码
- ❌ **禁止**直接复制他人代码
- ✅ 必须能够解释所有代码

### 开发环境
- ✅ **必须使用 Linux 操作系统**
- ✅ 确保所有代码在 Linux 上编译和运行
- ✅ 使用 GCC 编译器

---

## 📚 学习资源建议

### C 语言复习
- 指针和内存管理
- 结构体和链表
- 文件 I/O 操作
- 进程管理（fork, exec, wait）

### Linux 系统调用
- `fork()` - 创建进程
- `execv()` - 执行程序
- `chmod()` - 修改文件权限
- `opendir()`, `readdir()` - 目录操作

### 数据结构
- 链表实现
- 数组操作
- 字符串处理

---

## 🎯 评分标准速查

### Task 1 评分分布
- CLI: 15%
- 进程管理: 20%
- 文件管理: 20%
- NeuBoot: 15%
- 命令实现: 30%

### Task 2 评分分布
- **个人** (65%):
  - 技术理解: 25%
  - 问题回答: 25%
  - 沟通贡献: 15%
- **团队** (35%):
  - 准确性完整性: 15%
  - 批判性评估: 10%
  - 协作互动: 10%

---

## 📞 获取帮助

如果遇到困难：
1. 查看 Blackboard 上的相关材料
2. 联系单元负责人或助教
3. 利用 UWE Bristol 的评估支持选项
4. 咨询学生支持顾问

---

## 📅 时间管理建议

- **第 1-2 周**: 理论学习 + 团队组建
- **第 3-4 周**: 核心功能开发（CLI + 文件系统）
- **第 5 周**: 进程管理 + NeuBoot
- **第 6 周**: 优化 + 测试 + 视频录制
- **评审前**: 准备技术评审，复习代码

---

## 🎓 总结

这是一个综合性的操作系统项目，需要：
1. **扎实的 C 语言编程能力**
2. **对操作系统概念的理解**
3. **良好的团队协作**
4. **系统性的开发方法**

**建议从 CLI 开始**，这是最简单的部分，也是整个系统的基础。逐步构建其他子系统，确保每个部分都经过充分测试。

祝你好运！🚀